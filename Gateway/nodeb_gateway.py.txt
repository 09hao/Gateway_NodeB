#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Raspberry Pi 3B + SX1278 LoRa P2P Gateway (uplink -> ACK downlink)
# Compatible with Node B firmware "main_4s.c" (uplink every 4 s; app CRC16; expects immediate ACK)
# - RF params must match Node B
# - App-layer CRC16-CCITT on JSON "core" (w/o "crc" field)
# - Immediate ACK: {"ack": <seq>} (minimal) or verbose with RSSI/SNR
#
# Notes:
# * Keep ACK fast and short to fit the Node's post-TX RX window.
# * We de-duplicate log spam but still ACK duplicates (so the node can stop retrying).
# * Safe defaults kept from your previous script; cleaned up a bit for stability.

import time, json, sys, signal, struct
import spidev
import RPi.GPIO as GPIO

# ====== Wiring (BCM) ======
PIN_CS   = 8    # CE0 (SPI chip select)
PIN_RST  = 22   # Reset
PIN_DIO0 = 27   # RxDone / TxDone

# ====== RF config (must match Node B) ======
FREQ_HZ       = 433_000_000
SYNC_WORD     = 0x34
SPREADING_SF  = 9           # 7..12
BANDWIDTH_HZ  = 125000
CODERATE_DEN  = 5           # 5->4/5, 6->4/6, 7->4/7, 8->4/8
PREAMBLE_SYM  = 14
TX_POWER_DBM  = 17
OCP_MA        = 100         # 45..240 mA
USE_PA_BOOST  = True

# ====== ACK policy ======
ACK_DELAY_S     = 0.20      # small delay to let node re-enter RX
ACK_REPEATS     = 4         # send same ACK multiple times for robustness
ACK_SPACING_S   = 0.05
FULL_ACK        = False     # True -> include rssi/snr in ACK JSON

# ====== Misc ======
PRINT_DUPLICATES   = False   # still ACK duplicates but suppress spam logging
LOG_PREFIX         = "[GW] "
WATCHDOG_SEC       = 30      # if no RX activity for N seconds, re-init radio (0 to disable)

# ====== LoRa registers (SX1276/77/78) ======
REG_FIFO                 = 0x00
REG_OP_MODE              = 0x01
REG_FRF_MSB              = 0x06
REG_FRF_MID              = 0x07
REG_FRF_LSB              = 0x08
REG_PA_CONFIG            = 0x09
REG_OCP                  = 0x0B
REG_LNA                  = 0x0C
REG_FIFO_ADDR_PTR        = 0x0D
REG_FIFO_TX_BASE_ADDR    = 0x0E
REG_FIFO_RX_BASE_ADDR    = 0x0F
REG_FIFO_RX_CURRENT_ADDR = 0x10
REG_IRQ_FLAGS            = 0x12
REG_RX_NB_BYTES          = 0x13
REG_PKT_SNR_VALUE        = 0x19
REG_PKT_RSSI_VALUE       = 0x1A
REG_MODEM_CONFIG1        = 0x1D
REG_MODEM_CONFIG2        = 0x1E
REG_SYMB_TIMEOUT_LSB     = 0x1F
REG_PREAMBLE_MSB         = 0x20
REG_PREAMBLE_LSB         = 0x21
REG_PAYLOAD_LENGTH       = 0x22
REG_MODEM_CONFIG3        = 0x26
REG_DETECT_OPTIMIZE      = 0x31
REG_DETECTION_THRESHOLD  = 0x37
REG_SYNC_WORD            = 0x39
REG_DIO_MAPPING1         = 0x40
REG_VERSION              = 0x42
REG_PA_DAC               = 0x4D

# OP mode bits
MODE_LONG_RANGE_MODE = 0x80
MODE_SLEEP   = 0x00
MODE_STDBY   = 0x01
MODE_TX      = 0x03
MODE_RXCONT  = 0x05

# IRQ flags
IRQ_RXDONE    = 0x40
IRQ_TXDONE    = 0x08
IRQ_CRCERR    = 0x20

# constants
FXOSC  = 32000000.0
FSTEP  = FXOSC / (1 << 19)  # ~61.035 Hz

spi = spidev.SpiDev()

# ===== CRC16-CCITT (0xFFFF, poly 0x1021) =====
def crc16_ccitt(data: bytes) -> int:
    crc = 0xFFFF
    for b in data:
        crc ^= (b << 8) & 0xFFFF
        for _ in range(8):
            if (crc & 0x8000):
                crc = ((crc << 1) ^ 0x1021) & 0xFFFF
            else:
                crc = (crc << 1) & 0xFFFF
    return crc

def gpio_setup():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(PIN_RST, GPIO.OUT, initial=GPIO.HIGH)
    GPIO.setup(PIN_DIO0, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

def spi_setup():
    # SPI0 CE0, mode 0, max speed 8MHz (SX127x ok up to ~10MHz)
    spi.open(0, 0)
    spi.max_speed_hz = 8000000
    spi.mode = 0

# ===== Reg access =====
def w(addr, val): spi.xfer2([addr | 0x80, val & 0xFF])
def r(addr) -> int: return spi.xfer2([addr & 0x7F, 0])[1]
def bw(addr, payload: bytes): spi.xfer2([addr | 0x80] + list(payload))
def br(addr, n: int) -> bytes: return bytes(spi.xfer2([addr & 0x7F] + [0]*n)[1:])

def reset_chip():
    GPIO.output(PIN_RST, GPIO.LOW);  time.sleep(0.01)
    GPIO.output(PIN_RST, GPIO.HIGH); time.sleep(0.01)

def set_mode(m): w(REG_OP_MODE, MODE_LONG_RANGE_MODE | m)

def set_frequency(hz):
    frf = int(hz / FSTEP)
    w(REG_FRF_MSB, (frf >> 16) & 0xFF)
    w(REG_FRF_MID, (frf >> 8)  & 0xFF)
    w(REG_FRF_LSB, frf & 0xFF)

def set_tx_power(dbm, pa_boost=True):
    if pa_boost:
        w(REG_PA_CONFIG, 0x80 | max(0, min(15, dbm - 2)))
        w(REG_PA_DAC, 0x87 if dbm > 17 else 0x84)
    else:
        w(REG_PA_CONFIG, 0x70 | max(0, min(15, dbm)))
        w(REG_PA_DAC, 0x84)

def set_ocp(ma):
    ocp_trim = int((ma - 45)/5) if ma <= 120 else int((ma + 30)/10)
    ocp_trim = max(0, min(27, ocp_trim))
    w(REG_OCP, 0x20 | (ocp_trim & 0x1F))

def set_lna_boost(): w(REG_LNA, 0x23)

def bw_to_bits(hz):
    table = {7800:0, 10400:1, 15600:2, 20800:3, 31250:4, 41700:5, 62500:6, 125000:7, 250000:8, 500000:9}
    return table.get(hz, 7)

def set_modem(sf, bw_hz, cr_den, crc_on=True, explicit_header=True):
    bw_bits = bw_to_bits(bw_hz)
    cr_bits = max(1, min(4, cr_den - 4))  # 4/5->1 .. 4/8->4
    w(REG_MODEM_CONFIG1, (bw_bits << 4) | (cr_bits << 1) | (0 if explicit_header else 1))
    sf_bits = max(6, min(12, sf))
    w(REG_MODEM_CONFIG2, ((sf_bits << 4) & 0xF0) | (0x04 if crc_on else 0x00) | 0x03)
    w(REG_SYMB_TIMEOUT_LSB, 0xFF)
    symbol_us = (1 << sf_bits) * 1_000_000.0 / bw_hz
    w(REG_MODEM_CONFIG3, (0x08 if symbol_us > 16000 else 0x00) | 0x04)  # LDO + AGC
    if sf_bits >= 11:
        w(REG_DETECT_OPTIMIZE, 0x0B); w(REG_DETECTION_THRESHOLD, 0x0C)
    else:
        w(REG_DETECT_OPTIMIZE, 0x03); w(REG_DETECTION_THRESHOLD, 0x0A)
        
def set_syncword(sw): w(REG_SYNC_WORD, sw & 0xFF)
def set_preamble(nsym):
    w(REG_PREAMBLE_MSB, (nsym >> 8) & 0xFF)
    w(REG_PREAMBLE_LSB, nsym & 0xFF)

def enter_rx_continuous():
    w(REG_FIFO_RX_BASE_ADDR, 0x00)
    w(REG_FIFO_ADDR_PTR, 0x00)
    w(REG_DIO_MAPPING1, 0x00)       # DIO0 -> RxDone
    w(REG_IRQ_FLAGS, 0xFF)          # clear
    set_mode(MODE_RXCONT)

def read_packet():
    irq = r(REG_IRQ_FLAGS)
    if (irq & IRQ_RXDONE) == 0:
        return None
    # PHY CRC error -> drop
    if (irq & IRQ_CRCERR) != 0:
        w(REG_IRQ_FLAGS, 0xFF)
        return b"", {"crc_phy_ok": False}

    cur = r(REG_FIFO_RX_CURRENT_ADDR)
    n   = r(REG_RX_NB_BYTES)
    w(REG_FIFO_ADDR_PTR, cur)
    data = br(REG_FIFO, n)
    w(REG_IRQ_FLAGS, 0xFF)          # clear after read

    snr_reg  = r(REG_PKT_SNR_VALUE)
    snr_db   = (snr_reg - 256) / 4.0 if snr_reg > 127 else snr_reg / 4.0
    rssi_dbm = -164 + r(REG_PKT_RSSI_VALUE)
    return data, {"crc_phy_ok": True, "rssi": rssi_dbm, "snr": snr_db}

def transmit(payload: bytes, timeout_ms=2000):
    set_mode(MODE_STDBY)
    w(REG_FIFO_TX_BASE_ADDR, 0x00)
    w(REG_FIFO_ADDR_PTR, 0x00)
    bw(REG_FIFO, payload)
    w(REG_PAYLOAD_LENGTH, len(payload))
    w(REG_DIO_MAPPING1, 0x40)       # DIO0 -> TxDone
    w(REG_IRQ_FLAGS, 0xFF)
    set_mode(MODE_TX)

    t0 = time.time()
    while True:
        irq = r(REG_IRQ_FLAGS)
        if (irq & IRQ_TXDONE): w(REG_IRQ_FLAGS, 0xFF); break
        if (time.time() - t0) * 1000 > timeout_ms:
            set_mode(MODE_STDBY)
            return False
        time.sleep(0.001)

    enter_rx_continuous()
    return True

def lora_begin():
    reset_chip()
    w(REG_OP_MODE, MODE_SLEEP | MODE_LONG_RANGE_MODE); time.sleep(0.01)
    ver = r(REG_VERSION)
    set_mode(MODE_SLEEP)
    set_frequency(FREQ_HZ)
    set_syncword(SYNC_WORD)
    set_tx_power(TX_POWER_DBM, USE_PA_BOOST)
    set_ocp(OCP_MA)
    set_lna_boost()
    set_preamble(PREAMBLE_SYM)
    set_modem(SPREADING_SF, BANDWIDTH_HZ, CODERATE_DEN, True, True)
    w(REG_PAYLOAD_LENGTH, 0xFF)
    enter_rx_continuous()
    return ver

def json_core_without_crc(s: str) -> str:
    p = s.rfind(',"crc":"')
    return None if p == -1 else (s[:p] + "}")

def parse_crc_hex4(s: str):
    key = '"crc":"'
    i = s.rfind(key)
    if i < 0: return None
    i += len(key)
    if i + 4 > len(s): return None
    try: return int(s[i:i+4], 16)
    except: return None

def extract_int_field(s: str, key: str) -> int:
    i = s.find(key);  j = s.find(':', i)
    if i < 0 or j < 0: return -1
    j += 1
    while j < len(s) and s[j].isspace(): j += 1
    sign = -1 if j < len(s) and s[j] == '-' else 1
    if sign == -1: j += 1
    val, anyd = 0, False
    while j < len(s) and s[j].isdigit():
        val = val * 10 + (ord(s[j]) - 48); j += 1; anyd = True
    return sign * val if anyd else -1
    
def make_ack_full(seq: int, rssi: float, snr: float) -> bytes:
    ack = {"ack": int(seq), "seq": int(seq), "gw":"pi3b",
           "rssi": round(rssi,1), "snr": round(snr,1)}
    return json.dumps(ack, separators=(',',':')).encode()

def make_ack_min(seq: int) -> bytes:
    return ('{"ack":%d}' % int(seq)).encode()

def now_s(): return time.time()

def main():
    def handle_sig(sig, frame):
        print(LOG_PREFIX + "Exit on signal", sig)
        try:
            set_mode(MODE_STDBY)
        finally:
            spi.close()
            GPIO.cleanup()
        sys.exit(0)

    signal.signal(signal.SIGINT, handle_sig)
    signal.signal(signal.SIGTERM, handle_sig)

    gpio_setup()
    spi_setup()
    ver = lora_begin()
    print(LOG_PREFIX + f"Gateway ready (SX127x VER=0x{ver:02X}). Listening...")

    last_rx_time = now_s()
    last_seq_logged = None  # for log spam suppression only

    while True:
        pkt = read_packet()
        if not pkt:
            # Radio watchdog: re-init if silent too long (optional)
            if WATCHDOG_SEC and (now_s() - last_rx_time) > WATCHDOG_SEC:
                print(LOG_PREFIX + "Watchdog: re-init radio after inactivity")
                lora_begin()
                last_rx_time = now_s()
            time.sleep(0.002)
            continue

        data, meta = pkt
        last_rx_time = now_s()

        if not meta.get("crc_phy_ok", False):
            print(LOG_PREFIX + "[RX] CRC_PHY_ERROR (dropped)")
            continue

        try:
            s = data.decode('utf-8', errors='ignore').strip()
        except Exception:
            print(LOG_PREFIX + "[RX] decode error")
            continue

        core = json_core_without_crc(s)
        rx_crc = parse_crc_hex4(s)
        if not core or rx_crc is None:
            print(LOG_PREFIX + "No app CRC field; drop.")
            continue
        calc = crc16_ccitt(core.encode('utf-8'))
        if calc != rx_crc:
            print(LOG_PREFIX + f"App CRC FAIL (calc=0x{calc:04X}, rx=0x{rx_crc:04X}); drop.")
            continue

        seq = extract_int_field(s, '"seq"')
        # Logging with duplicate suppression (but still ACK later)
        if seq != last_seq_logged or PRINT_DUPLICATES:
            print(LOG_PREFIX + f"[RX] {s}  RSSI={meta['rssi']:.1f} dBm  SNR={meta['snr']:.1f} dB")
            last_seq_logged = seq

        # --- ACK ---
        if seq >= 0:
            time.sleep(ACK_DELAY_S)
            ack_bytes = make_ack_full(seq, meta["rssi"], meta["snr"]) if FULL_ACK else make_ack_min(seq)
            ok_any = False
            for i in range(ACK_REPEATS):
                ok_any |= transmit(ack_bytes, timeout_ms=2000)
                if i + 1 < ACK_REPEATS: time.sleep(ACK_SPACING_S)
            # concise log to avoid jitter impacting the next RX
            print(LOG_PREFIX + f"ACK seq={seq} x{ACK_REPEATS}: {'OK' if ok_any else 'TIMEOUT'}")
        else:
            print(LOG_PREFIX + "No 'seq' field; skip ACK.")

if __name__ == "__main__":
    main()
